<!doctype html>
<html>
<head>
<title>babylon test</title>
<style type="text/css">
html, body, div, canvas {
	width: 100%;
	height: 100%;
	padding: 0;
	margin: 0;
	overflow: hidden;
}
#debug {
	position: absolute;
	top: 0px;
	left: 0px;
	width: 100px;
	height: 150px;
	padding: 5px;
	font-family: "Monaco", "Courier New", "Courier", monospace;
	font-size: 14px;
	color: white;
	background-color: black;
	cursor: default;
}
</style>
</head>
<body>
<div id="debug"></div>
<div id="root"><canvas id="render"></canvas></div>
<audio id="thruster-sound" src="audio/thruster.wav" loop="loop" preload="auto"></audio>
<audio id="blaster-sound" src="audio/blaster.wav" preload="auto"></audio>
<!-- look at all of this babylon crap -->
<!-- <script src="hand-1.1.1.js"></script> -->
<script src="Babylon/Tools/babylon.math.js"></script>
<script src="Babylon/Tools/babylon.tools.js"></script>
<script src="Babylon/babylon.engine.js"></script>
<script src="Babylon/Culling/babylon.boundingSphere.js"></script>
<script src="Babylon/Culling/babylon.boundingBox.js"></script>
<script src="Babylon/Culling/babylon.boundingInfo.js"></script>
<script src="Babylon/Lights/babylon.light.js"></script>
<script src="Babylon/Lights/babylon.pointLight.js"></script>
<script src="Babylon/Lights/babylon.spotLight.js"></script>
<script src="Babylon/Lights/babylon.hemisphericLight.js"></script>
<script src="Babylon/Lights/babylon.directionalLight.js"></script>
<script src="Babylon/Lights/Shadows/babylon.shadowGenerator.js"></script>
<script src="Babylon/Collisions/babylon.collider.js"></script>
<script src="Babylon/Cameras/babylon.camera.js"></script>
<script src="Babylon/Cameras/babylon.freeCamera.js"></script>
<script src="Babylon/Cameras/babylon.touchCamera.js"></script>
<script src="Babylon/Cameras/babylon.arcRotateCamera.js"></script>
<script src="Babylon/babylon.scene.js"></script>
<script src="Babylon/Mesh/babylon.vertexBuffer.js"></script>
<script src="Babylon/Mesh/babylon.mesh.js"></script>
<script src="Babylon/Mesh/babylon.subMesh.js"></script>
<script src="Babylon/Materials/textures/babylon.baseTexture.js"></script>
<script src="Babylon/Materials/textures/babylon.texture.js"></script>
<script src="Babylon/Materials/textures/babylon.cubeTexture.js"></script>
<script src="Babylon/Materials/textures/babylon.renderTargetTexture.js"></script>
<script src="Babylon/Materials/textures/babylon.mirrorTexture.js"></script>
<script src="Babylon/Materials/textures/babylon.dynamicTexture.js"></script>
<script src="Babylon/Materials/textures/babylon.videoTexture.js"></script>
<script src="Babylon/Materials/babylon.effect.js"></script>
<script src="Babylon/Materials/babylon.material.js"></script>
<script src="Babylon/Materials/babylon.standardMaterial.js"></script>
<script src="Babylon/Materials/babylon.multiMaterial.js"></script>
<script src="Babylon/Tools/babylon.sceneLoader.js"></script>
<script src="Babylon/Sprites/babylon.spriteManager.js"></script>
<script src="Babylon/Sprites/babylon.sprite.js"></script>
<script src="Babylon/Layer/babylon.layer.js"></script>
<script src="Babylon/Particles/babylon.particle.js"></script>
<script src="Babylon/Particles/babylon.particleSystem.js"></script>
<script src="Babylon/Animations/babylon.animation.js"></script>
<script src="Babylon/Animations/babylon.animatable.js"></script>
<script src="Babylon/Culling/Octrees/babylon.octree.js"></script>
<script src="Babylon/Culling/Octrees/babylon.octreeBlock.js"></script>
<!-- custom stuff -->
<script src="babylon.cyle.js"></script>
<script src="spacegame.classes.js"></script>
<script>

function degreesToRadians(degrees) {
	return degrees * (Math.PI/180);
}

function randomFromInterval(from, to) {
    return Math.floor(Math.random() * (to-from+1) + from);
}

// get the debug element
var debug = document.getElementById("debug");

// Get the Canvas element from our HTML below
var canvas = document.getElementById("render");
// Load BABYLON 3D engine
var engine = new BABYLON.Engine(canvas, false);
var scene = new BABYLON.Scene(engine);

// Creating a camera looking to the zero point (0,0,0)
// arc camera: name, alpha (angle, in radians), beta (another angle, in radians), radius (how far away initially), pointing at, scene to add it to
var camera = new BABYLON.ArcRotateCamera("Camera", Math.PI/2, Math.PI/2, 25, new BABYLON.Vector3(0, 0, 0), scene);
// constrain the camera
camera.lowerRadiusLimit = 10;
camera.upperRadiusLimit = 50;
camera.lowerAlphaLimit = Math.PI * 0.33;
camera.upperAlphaLimit = Math.PI * 0.66;
camera.lowerBetaLimit = Math.PI * 0.33;
camera.upperBetaLimit = Math.PI * 0.66;
// later change ArcCamera's target and position with...
// arcCamera.target = new BABYLON.Vector3(3, 0, 0);
// arcCamera.setPosition(new BABYLON.Vector3(0, 0, 50));

// create a fill light
var light = new BABYLON.PointLight("Omni", new BABYLON.Vector3(25, 25, 25), scene);

// box: name, size of box, scene to add it to
var box = BABYLON.Mesh.CreateBox("Box", 4.0, scene);
box.position = new BABYLON.Vector3(-25,0,0);
box.rotation.x = Math.PI/3;
box.rotation.y = -Math.PI/3;
box.rotation.z = Math.PI/5;
// create a littler box, which will interact with the big box
var box2 = BABYLON.Mesh.CreateBox("Box2", 3.0, scene);
box2.parent = box;
box2.position.y = 10;
box2.material = new BABYLON.StandardMaterial("box2-material", scene);

// flat plane: name, size of plane, scene to add it to
var plane = BABYLON.Mesh.CreatePlane("Plane", 200.0, scene);
plane.position = new BABYLON.Vector3(0, 0, -8);
plane.rotation.y = -Math.PI;

// sphere: name, segments (detail), size, scene to add it to
var sphere = BABYLON.Mesh.CreateSphere("Sphere", 9.0, 3.0, scene);
sphere.position = new BABYLON.Vector3(15,0,0);
sphere.collideWith = true;
sphere.material = new BABYLON.StandardMaterial("texture", scene);
sphere.material.wireframe = true;

// cylinder: name, height, diameter, segments (detail), scene to add it to, whether it's updatable
var cylinder = BABYLON.Mesh.CreateCylinder("cylinder", 2, 2, 20, scene, false);
cylinder.position = new BABYLON.Vector3(15,5,0);

// torus: name, diameter, thickness, segments (detail), scene to add it to, whether it's updatable
var torus = BABYLON.Mesh.CreateTorus("torus", 5, 1, 20, scene, false);
torus.position = new BABYLON.Vector3(15,10,0);




// make a "safe box", used later
var safebox = BABYLON.Mesh.CreateRect("Safe Zone", 10, 20, 3, scene);
safebox.position = new BABYLON.Vector3(-15,15,0);
safebox.collideWith = true;
safebox.safeZone = true;
safebox.material = new BABYLON.StandardMaterial("texture", scene);
safebox.material.emissiveColor = new BABYLON.Color4(0, 1, 0, 1);
safebox.material.wireframe = true;

// make a "nebula box", used later
var nebulabox = BABYLON.Mesh.CreateRect("Nebula", 10, 20, 3, scene);
nebulabox.position = new BABYLON.Vector3(-15,-15,0);
nebulabox.collideWith = true;
nebulabox.nebula = true;
nebulabox.material = new BABYLON.StandardMaterial("texture", scene);
nebulabox.material.emissiveColor = new BABYLON.Color4(0.5, 0.0, 0.5, 1);
nebulabox.material.wireframe = true;

// just create random crap in the background
for (i = 0; i < 200; i++) {
	var newcrap = BABYLON.Mesh.CreateSphere("crap "+i, 3, 0.5, scene);
	newcrap.material = new BABYLON.StandardMaterial("crap-material", scene);
	newcrap.material.emissiveColor = new BABYLON.Color4(0.2, 0.2, 0.2, 1);
	newcrap.position.x = randomFromInterval(-100, 100);
	newcrap.position.y = randomFromInterval(-100, 100);
	newcrap.position.z = -4;
}

// add some asteroids
/*
for (i = 0; i < 100; i++) {
	var asteroid = BABYLON.Mesh.CreateSphere("asteroid "+i, 3, 1, scene);
	asteroid.material = new BABYLON.StandardMaterial("asteroid-material", scene);
	asteroid.material.emissiveColor = new BABYLON.Color4(0.6, 0.3, 0, 1);
	asteroid.position.x = randomFromInterval(-100, 100);
	asteroid.position.y = randomFromInterval(-100, 100);
	asteroid.collideWith = true;
	asteroid.solid = true;
}
*/

BABYLON.SceneLoader.ImportMesh("", "models/Spaceship/", "Spaceship.babylon", scene, function (newMeshes, particleSystems) {
	//console.log(newMeshes);
	for (i = 0; i < newMeshes.length; i++) {
		newMeshes[i].scaling = new BABYLON.Vector3(0.05, 0.05, 0.05);
		newMeshes[i].position = new BABYLON.Vector3(0, 10, 0);
		newMeshes[i].rotation = new BABYLON.Vector3(Math.PI/4, 0, 0);
	}
});

// add an asteroid "area"
var asteroidFieldX = 50;
var asteroidFieldY = 50;
for (i = 0; i < 100; i++) {
	var asteroidField = BABYLON.Mesh.CreateSphere("asteroidField "+i, 3, 1, scene);
	asteroidField.material = new BABYLON.StandardMaterial("asteroid-material", scene);
	asteroidField.material.emissiveColor = new BABYLON.Color4(0.6, 0.3, 0, 1);
	asteroidField.position.x = asteroidFieldX + randomFromInterval(-20, 20);
	asteroidField.position.y = asteroidFieldY + randomFromInterval(-20, 20);
	asteroidField.collideWith = true;
	asteroidField.solid = true;
}

// Attach the camera to the scene
scene.activeCamera.attachControl(canvas);

// move things around, do whatever you want, before the scene is rendered
var moveForward = false;
var moveReverse = false;
var rotateLeft = false;
var rotateRight = false;
var brake = false;

// create the player ship
var playerShip = new SpaceShip(0, 0, scene);
var bullets = [];

// key code reference: http://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes
// listen for keys going down, register them as movement
window.addEventListener('keydown', function(e) {
	switch (e.keyCode) {
		case 87: // w
		moveForward = true;
		break;
		case 65: // a
		rotateLeft = true;
		break;
		case 68: // d
		rotateRight = true;
		break;
		case 83: // s
		moveReverse = true;
		break;
		case 16:
		brake = true;
		break;
		default:
		//console.log('key pressed: ' + e.keyCode);
	}
});

// register keys coming back up, register them as stopping movement
window.addEventListener('keyup', function(e) {
	switch (e.keyCode) {
		case 87: // w
		moveForward = false;
		break;
		case 65: // a
		rotateLeft = false;
		break;
		case 68: // d
		rotateRight = false;
		break;
		case 83: // s
		moveReverse = false;
		break;
		case 16:
		brake = false;
		break;
		case 67: // c
		camera.alpha = Math.PI / 2;
		camera.beta = Math.PI / 2;
		break;
		case 77: // m
		console.log(scene.meshes);
		//console.log(playerShip.objects);
		break;
		case 32: // space bar
		bullets.push( new Bullet( playerShip.x, playerShip.y, playerShip.currentRotation, scene ) );
		document.getElementById('blaster-sound').play();
		break;
		default:
		//console.log('key released: ' + e.keyCode);
	}
});

var boxdir = true; // keep track of the little box's state

// this is the pre-render update() loop
scene.registerBeforeRender(function () {
	
	// move the little box back and forth
	//console.log(box2.position.y);
	if (boxdir == true && box2.position.y > -10) {
		box2.position.y -= 0.1;
		if (box2.position.y <= -10) {
			boxdir = false;
		}
	} else if (box2.position.y < 10 && boxdir == false) {
		box2.position.y += 0.1;
		if (box2.position.y >= 10) {
			boxdir = true;
		}
	}
	
	// normal box color:
	box2.material.emissiveColor = new BABYLON.Color4(0, 0, 0, 1);
	// if the box intersects with the other box, turn it red!
	if (box2.intersectsMesh(box, true)) {
		box2.material.emissiveColor = new BABYLON.Color4(1, 0, 0, 1);
	}
	
	// ship rotation
	if (rotateLeft && !rotateRight) { // rotate left
		playerShip.rotate(-1);
	}
	
	if (!rotateLeft && rotateRight) { // rotate right
		playerShip.rotate(1);
	}
	
	// thrust forward / reverse
	if (moveForward || moveReverse) { // thrusting
		document.getElementById('thruster-sound').play();
		if (moveForward && !moveReverse) { // thrust forward
			playerShip.setDirection(1);
		}
		if (!moveForward && moveReverse) { // thrust reverse
			playerShip.setDirection(-1);
		}
	} else {
		playerShip.setDirection(0);
		document.getElementById('thruster-sound').pause();
	}
	
	if (brake) {
		playerShip.brake();
	}
	
	playerShip.update();
		
	playerShip.checkCollisions(scene);
	
	for (i = 0; i < bullets.length; i++) { // go through the bullets
		bullets[i].update(); // update!
		if (bullets[i].done == true) {
			bullets[i].update(); // run its own cleanup
			bullets.splice(i, 1); // remove from the array of bullets
		}
	}
	
	// have the camera move based on the player ship
	camera.target.x = playerShip.x;
	camera.target.y = playerShip.y;
	
	// have the light follow the camera
	//light.position = camera.position;
	
	//console.log('Camera alpha: ' + camera.alpha + ', beta: ' + camera.beta);
	
});

// Once the scene is loaded, just register a render loop to render it
engine.runRenderLoop(function () {
	scene.render();
});

// handle window resize
window.addEventListener("resize", function() {
	engine.resize();
});

function prettyNum(num) {
	return Math.round(num * 100)/100;
}

// debug info
setInterval(function() {
	debug_txt = '';
	debug_txt += 'FPS: ' + BABYLON.Tools.GetFps().toPrecision(4) + '<br />';
	debug_txt += 'X: ' + prettyNum(playerShip.x) + '<br />';
	debug_txt += 'Y: ' + prettyNum(playerShip.y) + '<br />';
	debug_txt += 'mR: ' + prettyNum(playerShip.movingRotation) + '<br />';
	debug_txt += 'cR: ' + prettyNum(playerShip.currentRotation) + '<br />';
	debug_txt += 'S: ' + prettyNum(playerShip.currentSpeed) + '<br />';
	debug_txt += 'CamA: ' + prettyNum(camera.alpha) + '<br />';
	debug_txt += 'CamB: ' + prettyNum(camera.beta) + '<br />';
	debug.innerHTML = debug_txt;
}, 100);

</script>
</body>
</html>
