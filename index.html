<!doctype html>
<html>
<head>
<title>babylon test</title>
<style type="text/css">
html, body, div, canvas {
	width: 100%;
	height: 100%;
	padding: 0;
	margin: 0;
	overflow: hidden;
}
#debug {
	position: absolute;
	top: 0px;
	left: 0px;
	width: 100px;
	height: 150px;
	padding: 5px;
	font-family: "Monaco", "Courier New", "Courier", monospace;
	font-size: 14px;
	color: white;
	background-color: black;
	cursor: default;
}
</style>
</head>
<body>
<div id="debug"></div>
<div id="root"><canvas id="render"></canvas></div>
<script src="babylon.1.3.0.js"></script>
<!-- <script src="hand-1.1.1.js"></script> -->
<script>

function degreesToRadians(degrees) {
	return degrees * (Math.PI/180);
}

function randomFromInterval(from, to) {
    return Math.floor(Math.random() * (to-from+1) + from);
}

// get the debug element
var debug = document.getElementById("debug");

// Get the Canvas element from our HTML below
var canvas = document.getElementById("render");
// Load BABYLON 3D engine
var engine = new BABYLON.Engine(canvas, false);
var scene = new BABYLON.Scene(engine);

// Creating a camera looking to the zero point (0,0,0)
// arc camera: name, alpha (angle, in radians), beta (another angle, in radians), radius (how far away initially), pointing at, scene to add it to
var camera = new BABYLON.ArcRotateCamera("Camera", Math.PI/2, Math.PI/2, 15, new BABYLON.Vector3(0, 0, 0), scene);
// constrain the camera
camera.lowerRadiusLimit = 10;
camera.upperRadiusLimit = 20;
camera.lowerAlphaLimit = Math.PI * 0.33;
camera.upperAlphaLimit = Math.PI * 0.66;
camera.lowerBetaLimit = Math.PI * 0.33;
camera.upperBetaLimit = Math.PI * 0.66;
// later change ArcCamera's target and position with...
// arcCamera.target = new BABYLON.Vector3(3, 0, 0);
// arcCamera.setPosition(new BABYLON.Vector3(0, 0, 50));

// create a fill light
var light = new BABYLON.PointLight("Omni", new BABYLON.Vector3(25, 25, 25), scene);

// objects are at 0, 0, 0 by default, unless you specify otherwise after calling them
//var origin = BABYLON.Mesh.CreateSphere("origin", 10, 1.0, scene);
var origin = BABYLON.Mesh.CreateBox("origin", 1.0, scene);
origin.material = new BABYLON.StandardMaterial("origin-material", scene);

// box: name, size of box, scene to add it to
var box = BABYLON.Mesh.CreateBox("Box", 4.0, scene);
box.position = new BABYLON.Vector3(-5,0,0);
box.rotation.x = Math.PI/3;
box.rotation.y = -Math.PI/3;
box.rotation.z = Math.PI/5;

// create a littler box
var box2 = BABYLON.Mesh.CreateBox("Box2", 3.0, scene);
box2.parent = box;
box2.position.y = 10;
box2.material = new BABYLON.StandardMaterial("box2-material", scene);

// sphere: name, segments (detail), size, scene to add it to
var sphere = BABYLON.Mesh.CreateSphere("Sphere", 9.0, 3.0, scene);
sphere.position = new BABYLON.Vector3(5,0,0);

// flat plane: name, size of plane, scene to add it to
var plane = BABYLON.Mesh.CreatePlane("Plane", 50.0, scene);
plane.position = new BABYLON.Vector3(0, 0, -30);
plane.rotation.y = -Math.PI;

for (i = 0; i < 200; i++) {
	// just create random crap in the background
	var newcrap = BABYLON.Mesh.CreateSphere("crap "+i, 3, 0.5, scene);
	newcrap.position.x = randomFromInterval(-100, 100);
	newcrap.position.y = randomFromInterval(-100, 100);
	newcrap.position.z = -4;
}

// cylinder: name, height, diameter, segments (detail), scene to add it to, whether it's updatable
var cylinder = BABYLON.Mesh.CreateCylinder("cylinder", 2, 2, 20, scene, false);
cylinder.position = new BABYLON.Vector3(0,-5,0);

// torus: name, diameter, thickness, segments (detail), scene to add it to, whether it's updatable
var torus = BABYLON.Mesh.CreateTorus("torus", 5, 1, 20, scene, false);
torus.position = new BABYLON.Vector3(0,5,0);

// Attach the camera to the scene
scene.activeCamera.attachControl(canvas);

// move things around, do whatever you want, before the scene is rendered
var moveForward = false;
var moveReverse = false;
var rotateLeft = false;
var rotateRight = false;

// listen for keys going down, register them as movement
window.addEventListener('keydown', function(e) {
	switch (e.keyCode) {
		case 87: // w
		moveForward = true;
		break;
		case 65: // a
		rotateLeft = true;
		break;
		case 68: // d
		rotateRight = true;
		break;
		case 83: // s
		moveReverse = true;
		break;
		case 67: // c
		camera.alpha = Math.PI / 2;
		camera.beta = Math.PI / 2;
		default:
		//console.log('key pressed: ' + e.keyCode);
	}
});

// register keys coming back up, register them as stopping movement
window.addEventListener('keyup', function(e) {
	switch (e.keyCode) {
		case 87: // w
		moveForward = false;
		break;
		case 65: // a
		rotateLeft = false;
		break;
		case 68: // d
		rotateRight = false;
		break;
		case 83: // s
		moveReverse = false;
		break;
		default:
		//console.log('key released: ' + e.keyCode);
	}
});

var boxdir = true; // keep track of the little box's state

// player box info
var currentlyThrusting = false;
var currentSpeed = 0.0;
var currentRotation = 0.0;
var movingRotation = 0.0;
var maxSpeed = 0.2;
var minSpeed = -0.1;
var accelerationRate = 0.01;
var actualAccelRate = 0.0;
var rotationRate = 0.1;
var rotationThrustRate = 0.1;

// this is the pre-render update() loop
scene.registerBeforeRender(function () {
	
	// move the little box back and forth
	//console.log(box2.position.y);
	if (boxdir == true && box2.position.y > -10) {
		box2.position.y -= 0.1;
		if (box2.position.y <= -10) {
			boxdir = false;
		}
	} else if (box2.position.y < 10 && boxdir == false) {
		box2.position.y += 0.1;
		if (box2.position.y >= 10) {
			boxdir = true;
		}
	}
	
	// normal box color:
	box2.material.emissiveColor = new BABYLON.Color4(0, 0, 0, 1);
	// if the box intersects with the other box, turn it red!
	if (box2.intersectsMesh(box, true)) {
		box2.material.emissiveColor = new BABYLON.Color4(1, 0, 0, 1);
	}
	
	// ship rotation
	if (rotateLeft && !rotateRight) { // rotate left
		origin.rotation.z -= rotationRate;
	}
	
	if (!rotateLeft && rotateRight) { // rotate right
		origin.rotation.z += rotationRate;
	}
	
	// keep rotation within bounds
	if (origin.rotation.z > Math.PI * 2) {
		origin.rotation.z = 0;
	} else if (origin.rotation.z < 0) {
		origin.rotation.z = Math.PI * 2;
	}
	
	// thrust forward / reverse
	if (moveForward || moveReverse) { // thrust forward
		currentlyThrusting = true;
	} else {
		currentlyThrusting = false;
	}
	
	// keep speed within bounds
	if (currentSpeed > maxSpeed) {
		currentSpeed = maxSpeed;
	}
	if (currentSpeed < minSpeed) {
		currentSpeed = minSpeed;
	}
	
	currentRotation = origin.rotation.z;
	
	// if we are thrusting in a direction, try to move along the ship's current rotation
	if (movingRotation != currentRotation && currentlyThrusting) {
		
		// get the opposite angle to how we are currently moving
		var oppositeMovingAngle = 0.0;
		if (movingRotation <= Math.PI * 2 && movingRotation > Math.PI) {
			oppositeMovingAngle = movingRotation - Math.PI;
		} else {
			oppositeMovingAngle = movingRotation + Math.PI;
		}
		//console.log('opposite angle to how we are moving: ' + oppositeMovingAngle);
		
		// get the difference between how we are moving and how we want to move
		var angleDiff = Math.abs(movingRotation - currentRotation);
		if (angleDiff > Math.PI) {
			angleDiff = (Math.PI * 2) - angleDiff;
		}
		console.log('angle diff between current moving and facing: ' + angleDiff + '/' + Math.PI);
		console.log('percent diff: ' + Math.round((angleDiff / Math.PI) * 100) );
		
		/*
		
		ugh, what the fuuuuuuck
		
		what to do:
		
		- if the new angle (current facing direction) is near a 180-degree turn, (WIDE TURN THRESHOLD)
			make the ship slow til it reaches 0 and then accelerate in the new direction
		- if the new angle is within the 90-degree cone of where you were moving, (ACUTE TURN THRESHOLD)
			make the ship slow down a tiny bit til it reaches the new angle
		- if the new angle is not a full 180, but over the 90-degree cone, (REGULAR TURN THRESHOLD)
			make the ship slow down a little and then accelerate as usual
		
		*/
		
		
		/*
		
		measurements...
		relative direction, PI, degrees, radians
		
		STRAIGHT AHEAD = PI * 0 or 0 degrees or 0 radians
		RIGHT = PI * 0.5 or 90 degrees or ~1.57 radians
		BACKWARDS = PI * 1 or 180 degrees or ~3.14 radians
		LEFT = PI * 1.25 or 270 degrees or ~3.93 radians
		FULL CIRCLE = PI * 2 or 360 degrees or ~6.28 radians
		
		*/
		
		//movingRotation += currentRotation/10;
		//movingRotation = currentRotation + (angleDiff * (angleDiff / Math.PI)); // what????
		movingRotation = currentRotation;
		actualAccelRate = accelerationRate;
		
		if (moveForward && !moveReverse) { // thrust forward
			currentSpeed += actualAccelRate;
		}
		
		if (!moveForward && moveReverse) { // thrust reverse
			currentSpeed -= actualAccelRate;
		}
		
	} else if (movingRotation == currentRotation && currentlyThrusting) { // we are just moving straight ahead
		
		// accelerate!
		
		if (moveForward && !moveReverse) { // thrust forward
			currentSpeed += accelerationRate;
		}
		
		if (!moveForward && moveReverse) { // thrust reverse
			currentSpeed -= accelerationRate;
		}
		
	} else {
		
		// we are not thrusting, so just keep moving straight at the same speed
		
	}
	
	// move the ship
	origin.position.x = origin.position.x + Math.sin(movingRotation) * -currentSpeed;
	origin.position.y = origin.position.y + Math.cos(movingRotation) * currentSpeed;
	
	// origin sphere's normal color...
	origin.material.emissiveColor = new BABYLON.Color4(0, 0, 0, 1);
	
	// turn the origin sphere red if it goes into the other sphere
	if (origin.intersectsMesh(sphere, true)) {
		origin.material.emissiveColor = new BABYLON.Color4(1, 0, 0, 1);
	}
	
	// turn the origin sphere blue if it goes into the torus
	if (origin.intersectsMesh(torus, true)) {
		origin.material.emissiveColor = new BABYLON.Color4(0, 0, 1, 1);
	}
	
	// have the camera move based on the origin sphere
	camera.target = origin.position;
	// have the light follow the camera
	//light.position = camera.position;
	
	//console.log('Camera alpha: ' + camera.alpha + ', beta: ' + camera.beta);
	
});

// Once the scene is loaded, just register a render loop to render it
engine.runRenderLoop(function () {
	scene.render();
});

// handle window resize
window.addEventListener("resize", function() {
	engine.resize();
});

function prettyNum(num) {
	return Math.round(num * 100)/100;
}

// debug info
setInterval(function() {
	debug_txt = '';
	debug_txt += 'FPS: ' + BABYLON.Tools.GetFps().toPrecision(4) + '<br />';
	debug_txt += 'X: ' + prettyNum(origin.position.x) + '<br />';
	debug_txt += 'Y: ' + prettyNum(origin.position.y) + '<br />';
	debug_txt += 'mR: ' + prettyNum(movingRotation) + '<br />';
	debug_txt += 'cR: ' + prettyNum(currentRotation) + '<br />';
	debug_txt += 'S: ' + prettyNum(currentSpeed);
	debug.innerHTML = debug_txt;
}, 100);

</script>
</body>
</html>